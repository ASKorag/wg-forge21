### Описать алгоритм реализации очереди с использованием двух стеков. Достаточно только текстового описания.

Сначала создаём 2 стека - `S1` и `S2`. Метод очереди `enqueue(value)` реализуем через `S1.push(value)`. Метод очереди `dequeue()` реализуем следующим образом:
1. Проверяем количество элементов `S2`. Если в нём есть элементы, то возвращаем `S2.pop()`.
2. Если `S2` пуст, то мы проверяем количество элементов `S1`. Если `S1` тоже пуст, то можно выкинуть ошибку о пустоте очереди.
3. Если же в `S1` есть элементы, то с помощью цикла поэлементно переносим все данные из `S1` в `S2` `(S2.push(S1.pop())`. Таким образом все данные `S1` в обратном порядке помещаются в `S2`.
4. После этого возвращаем `S2.pop()`.

### Предположим, что в реализации хеш-таблицы методом цепочек мы решили хранить каждый список отсортированным. Как это повлияет на время работы поиска существующего ключа, поиска отсутствующего ключа, добавления и удаление ключа?

### Рассмотрим односвязный список. Если идти от его начала по указателям на следующий элемент, то мы дойдем до хвоста списка - когда указатель не будет ни на что указывать. Однако, если где-то в списке есть петля (какой-то указатель ссылается на один из предыдущих элементов), то конца списка мы не достигнем. Требуется проверить спикок на наличие петель за О(количество элементов) и О(1) памяти. Длина списка само собой заранее не известна. Достаточно только описания алгоритма.

### Предположим, что в хеш-таблице в качестве цепочек используются односвязные списки. Пусть у нас есть указатель на один из элементов какого-то списка.Требуется удалить за О(1) этот элемент. Достаточно только описания алгоритма.
