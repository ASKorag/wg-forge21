### Описать алгоритм реализации очереди с использованием двух стеков. Достаточно только текстового описания.

Сначала создаём 2 стека - `S1` и `S2`. Метод очереди `enqueue(value)` реализуем через `S1.push(value)`. Метод очереди 
`dequeue()` реализуем следующим образом:
1. Проверяем количество элементов `S2`. Если в нём есть элементы, то возвращаем `S2.pop()`.
2. Если `S2` пуст, то мы проверяем количество элементов `S1`. Если `S1` тоже пуст, то можно выкинуть ошибку о пустоте 
3. очереди.
4. Если же в `S1` есть элементы, то с помощью цикла поэлементно переносим все данные из `S1` в `S2` `(S2.push(S1.pop())`.
5. Таким образом все данные `S1` в обратном порядке помещаются в `S2`.
6. После этого возвращаем `S2.pop()`.

### Предположим, что в реализации хеш-таблицы методом цепочек мы решили хранить каждый список отсортированным. Как это повлияет на время работы поиска существующего ключа, поиска отсутствующего ключа, добавления и удаление ключа?

Сначала несколько допущений:
1. Предполагаем, что у нас есть хорошая хеш-функция. Тогда все списки будут иметь длину близкую к `k = n/m`, где
`n` - количество ключей, `m` - количество ячеек хеш-таблицы.
2. Список отсортирован по возрастанию

#### Добавление ключа
Если у нас уже есть указатель на ключ, после которого нужно вставить новый ключ, то сложность будет `O(1)`. Если же нам 
нужно найти место - `O(k)`. В обычном списке у нас может быть указатель на хвост списка - сложность добавления `O(1)`, 
либо же можно вставлять в начало списка - сложность `O(1)`. Если нужно вставить в конец списка, а указателя 
нет - сложность `O(k)`.

#### Поиск отсутствующего ключа
Так как список отсортирован, нам достаточно перемещаться по списку и просматривать значения ключей. Если значение 
просматриваемого ключа будет больше, чем искомый ключ - значит в списке нет искомого ключа - сложность в лучшем случае
будет `O(1)` (первый ключ списка больше искомого), в среднем и худшем - `О(k)`. В обычном списке придётся пройти весь 
список - сложность `O(k)`.

#### Поиск существующего ключа
Рассуждения аналогичны с поиском отсутствующего ключа. Лучший случай - `O(1)`, средний и худший - `O(k)`. В обычном 
списке сложности такие же.

#### Удаление ключа
Если у нас есть указатель на удаляемый ключ и фокус с подменой ключей считается честным, то можно попробовать удалить 
ключи в обоих списках можно за `O(1)`. В общем случае нам нужно будет пройтись по списку, найти предыдущий, удаляемый и
следующий ключи, удалить нужный ключ, переписать ссылку в предыдущем ключе. Для обоих списков сложность будет в лучшем 
случае `O(1)`, в худшем - `O(k)`.

### Рассмотрим односвязный список. Если идти от его начала по указателям на следующий элемент, то мы дойдем до хвоста списка - когда указатель не будет ни на что указывать. Однако, если где-то в списке есть петля (какой-то указатель ссылается на один из предыдущих элементов), то конца списка мы не достигнем. Требуется проверить спикок на наличие петель за О(количество элементов) и О(1) памяти. Длина списка само собой заранее не известна. Достаточно только описания алгоритма.

Для поиска цикла воспользуемся алгоритмом Флойда. Для этого нам понадобится 2 указателя: `fast` и `slow`. Особенность их
в том, что указатель `fast` передвигается в 2 раза быстрее указателя `slow`. Признаком цикла будет равенство указателей.

1. Сначала проверяем указатель списка `head`. Если `head === null`, значит список пуст, зацикливания нет -> возвращаем `false`.
2. Создаём 2 указателя: `slow = head`, `fast = head.next`.
3. Запускаем бесконечный цикл. В цикле на каждой итерации проверяем:
   1. Если `slow === fast`, то значит мы попали в цикл, указатель `fast` прошёл по петле и “догнал” указатель
     `slow` -> возвращаем `true`.
   2. Если `fast === null` или `fast.next === null`, то значит зацикливания нет -> возвращаем `false` (проверяем перешли ли мы
      с последнего элемента списка на `null` или же `fast` указывает на последний элемент списка и следующий элемент `null`).
   Иначе передвигаем указатели: `slow = slow.next`, `fast = fast.next.next`

### Предположим, что в хеш-таблице в качестве цепочек используются односвязные списки. Пусть у нас есть указатель на один из элементов какого-то списка.Требуется удалить за О(1) этот элемент. Достаточно только описания алгоритма.

Можно попробовать сделать это через подмену узла. Когда предыдущий элемент будет ссылаться на наш удаляемый узел он 
будет получать полную копию следующего за удаляемым узла. Удаляемый узел - `deletedNode`. Следующий узел - `secondNode`.
Тогда можно сделать так:
`secondNode = deletedNode.next`

`deletedNode.key = secondNode.key`

`deletedNode.value = secondNode.value`

`deletedNode.next = secondNode.next`  

Теперь можно просто удалить узел `secondNode`, ибо наш удаляемый узел полностью копирует его. Либо сборщик мусора сам 
удалит его, либо можем самостоятельно вызвать удаление узла `secondNode`.
Если удаляемый узел последний, то можно попробовать через указатель обнулить узел.